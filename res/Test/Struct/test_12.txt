SOURCE
struct ListNode<T> {
	ListNode<T>* next;
	T value;
}

struct List<T> {
	ListNode<T>* head;
	ListNode<T>* tail;
}

List<T>* create<T>() {
	List<T>* lp = (List*) resv(sizeof(List<T>));

	*lp = List<T>::((ListNode*) 0, (ListNode*) 0);

	return lp;
}

void destroy(List<T>* l) {
	ListNode<T>* n = l->head;
	while ((int) n != 0) {
		free(n);
		n = n->next;
	}
	free(l);
}

void add<T>(List<T>* lp, T x) {
	ListNode<T>* n = (ListNode*) resv(sizeof(ListNode<T>));

	*n = ListNode<T>::((ListNode*) 0, x);

	if ((int) lp->head == 0) {
		lp->head = n;
		lp->tail = n;
	}
	else {
		lp->tail->next = n;
		lp->tail = n;
	}	
}

T get<T>(List<T>* lp, int i) {
	ListNode<T>* n = lp->head;
	while (i != 0) {
		if ((int) n->next == 0) return 0;
		
		/* Jump to next */
		n = n->next;
		i--;
	}
	
	return n->value;	
}

int main(int x) {
	List<int>* l = create<int>();
	add<int>(l, 10);
	add<int>(l, 5);
	add<int>(l, 12);
	
	int r = get<int>(l, x);
	
	destroy(l);
	
	return r;
}
TESTCASES
0 10
1 5
2 12