SOURCE
struct ContextException {
	int code;
}

struct Exception {
	int i0;
	int s0;
}

int get(int* arr, int i, int s) signals Exception {
	if (i >= s || i < 0) {
		signal Exception::(i, s);
	}
	else {
		return *(arr + i);
	}
}

int main(int i) {
	int [3] arr = {5, 3, 8};
	
	int r = 0;
	try {
		r = get(&arr, i, 3);
	} watch (Exception e) {
		r = e.i0 << 1 + e.s0;
	}
	
	return r;
}
TESTCASES
0 5
1 3
2 8
3 12
4 19
OUTPUT
/* --test_00.txt */
.data
HEAP_START: .word 0
    
.text
    b main
get:                          /* Function: get */
    push { r3, r4, r5, r12, r6 }
    mov r3, r0
    mov r4, r1
    mov r5, r2
    cmp r4, r5
    movge r0, #1
    movlt r0, #0
    push { r0 }
    cmp r4, #0
    movlt r0, #1
    movge r0, #0
    mov r1, r0
    pop { r0 }
    orrs r0, r0, r1
    movne r0, #1
    moveq r0, #0
    cmp r0, #0
    beq get.L0
    mov r0, r5
    push { r0 }
    mov r0, r4
    push { r0 }
    mov r12, #1               /* Signal thrown exception */
    mov r0, #8
    b main.L1
get.L0: 
    mov r6, r0                /* Evaluate Expression */
    add r0, r3, r4
    lsl r0, r0, #2            /* Convert to bytes */
    ldr r0, [r0]              /* Load from address */
    b get.L2
main.L1: 
get.L2: 
    cmp r12, #0
    mov r2, sp
    mov sp, fp
    pop { r3, r4, r5, r12, r6, fp }
    beq get.L3
    add r1, r2, r0
get.L4:                       /* Copy stack return with loop */
    cmp r0, #0
    beq get.L5
    ldr r2, [r1, #-4]!
    push { r2 }
    sub r0, r0, #4
    b get.L4
get.L5: 
get.L3: 
    bx lr
    
main:                         /* Function: main */
    push { r3, r4 }
    mov fp, sp
    mov r3, r0
    mov r0, #8                /* Evaluate Expression */
    mov r1, #3
    mov r2, #5
    push { r2, r1, r0 }
    mov r0, #0                /* Evaluate Expression */
    mov sp, fp
    pop { r3, r4 }
    bx lr
    
