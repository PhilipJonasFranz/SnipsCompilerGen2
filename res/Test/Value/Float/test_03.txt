SOURCE
struct Vector3F {

	float x;
	int y;
	float z;

}

float norm(Vector3F* vec) {
	return vec->x + (float) vec->y + vec->z;
}

float main() {
	Vector3F vec = Vector3F::(2.5f, 2, 0f);
	return norm(&vec);
}

TESTCASES
4.5
OUTPUT
.version 0

.data
Vector3F: .word 0
NULL: .word 0
HEAP_START: .word 0

.text
    b main

.global norm
norm:                                        /* Function: norm */
    lsl r1, r0, #2                           /* Convert to bytes */
    vldr s0, [r1, #4]                        /* Load field from struct */
    vpush { s0 }
    vldr s0, [r1, #8]
    vcvt.S32.F32 s2, s0
    vpop { s0 }
    vadd.F32 s0, s0, s2
    vldr s2, [r1, #12]
    vmov.F32 s1, s0
    vadd.F32 s0, s0, s2
    bx lr

.global main
main:                                        /* Function: main */
    push { fp, lr }
    mov fp, sp
    vldr s0, .P1294068183_LIT_0              /* Evaluate Expression */
    vpush { s0 }
    mov r0, #2
    push { r0 }
    vldr s0, .P1294068183_LIT_1075838976     /* Load value '2.5' from pool */
    vpush { s0 }
    ldr r0, .P1294068183_Vector3F
    push { r0 }
    sub r0, fp, #16                          /* Evaluate Expression */
    lsr r0, r0, #2
    bl norm                                  /* Call norm */
    mov sp, fp
    ldmfd sp!, {fp, pc}
.P1294068183_Vector3F: .word Vector3F
.P1294068183_LIT_1075838976: .word 1075838976
.P1294068183_LIT_0: .word 0
