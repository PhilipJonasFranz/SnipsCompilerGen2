namespace List {
	/*
	 * A single list entry, contains a pointer to the next node
	 * and a value.
	 */
	struct ListNode<T> {
		ListNode<T>* next;
		T value;
	}
	
	/*
	 * Wraps the list head and tail.
	 */
	struct LinkedList<T> {
		ListNode<T>* head;
		ListNode<T>* tail;
	}
	
	/*
	 * Creates a new List Object and initializes the head an tail to 0.
	 */
	LinkedList<T>* create<T>() {
		LinkedList<T>* lp = (LinkedList<T>*) resv(sizeof(LinkedList<T>));
	
		/* Initialize list, set pointers to 0 */
		*lp = LinkedList<T>::((ListNode<T>*) 0, (ListNode<T>*) 0);
	
		return lp;
	}
	
	/*
	 * Free the list by freeing all contained list nodes, and the list itself.
	 */
	void destroy(LinkedList<void>* l) {
		ListNode<void>* n = l->head;
		while ((int) n != 0) {
			free(n);
			n = n->next;
		}
		free(l);
	}
	
	/*
	 * Creates a new list node for given value x and adds the node at the
	 * end of the list.
	 */
	void add<T>(LinkedList<T>* lp, T x) {
		ListNode<T>* n = (ListNode<T>*) resv(sizeof(ListNode<T>));
	
		/* Initialize the new List Node, set the next pointer to null */
		*n = ListNode<T>::((ListNode<T>*) 0, x);
	
		if ((int) lp->head == 0) {
			lp->head = n; // Dereference through pointer
			lp->tail = n;
		}
		else {
			lp->tail->next = n;
			lp->tail = n;
		}	
	}
	
	/*
	 * Creates a new list node for given value x and adds the node at the
	 * end of the list.
	 */
	T get<T>(LinkedList<T>* lp, int i) {
		ListNode<T>* n = lp->head;
		while (i != 0) {
			if ((int) n->next == 0) return (T) 0;
			
			/* Jump to next */
			n = n->next;
			i--;
		}
		
		return n->value;	
	}
	
	/*
	 * Check if given list contains given value.
	 */
	bool contains<T>(LinkedList<T>* lp, T x) {
		ListNode<T>* n = lp->head;
		while (true) {
			if ((int) n == 0) return false;
			if (n->value == x) {
				/* Value found */
				return true;
			}
			/* Jump to next */
			n = n->next;
		}
	}
	
	/*
	 * Finds the first node in the list that has given value.
	 * Returns a pointer to this list node, or 0 in case the
	 * value wasnt found. Frees the removed node of the heap.
	 */
	ListNode<T>* find<T>(LinkedList<T>* lp, T x) {
		ListNode<T>* n = lp->head;
		while ((int) n->next != 0) {
			if (n->value == x) {
				return n;
			}
			/* Jump to next */
			n = n->next;
		}
		/* Not found */
		return (ListNode<T>*) 0;
	}
	
	/*
	 * Returns the amount of elements stored in the list.
	 */
	int size(LinkedList<void>* lp) {
		ListNode<void>* n = lp->head;
		int size = 0;
		while ((int) n != 0) {
			n = n->next;
			size++;
		}
		return size;
	}
	
	/*
	 * Removes the index at given index.
	 * If the index is out of bounds nothing is removed.
	 */
	void remove(LinkedList<void>* lp, int i) {
		/* Out of bounds */
		if (i < 0) return;
		
		if (i == 0) {
			/* Remove first element */
			if ((int) lp->head != 0) {
				ListNode<void>* n = lp->head;
				lp->head = lp->head->next;
				
				/* Only one element in list */
				if (lp->tail == n) {
					lp->tail = (ListNode<void>*) 0;
				}
				
				free(n);
			}
			
			return;
		}
		else {
			ListNode<void>* n = lp->head;
			i--;
			
			/* Jump to element before element to remove */
			while (i > 0) {
				if ((int) n->next == 0) return;
				else {
					n = n->next;
					i--;
				}
			}
			
			/* Out of bounds */
			if ((int) n->next == 0) return;
			else {
				if ((int) n->next->next == 0) {
					/* Element to remove is last element in list */
					free(n->next);
					n->next = (ListNode<void>*) 0;
					lp->tail = n;
				}
				else {
					/* Cut out element and set next pointers */
					ListNode<void>* next = n->next->next;
					free(n->next);
					n->next = next;
				}
				return;
			}
		}
		
	}
}