namespace FMath {

	static float E = 2.71828182846f;
	
	static float PI = 3.14159265359f;

    shared float abs(float x) {
    	asm {
    	    vabs s0, s0
    	};
    }

	shared float sqrt(float x) {
    	asm {
    	    vsqrt s0, s0
    	};
    }

	shared float fac(int n) {
		float r = 1f;
		while (n > 0) {
			r = r * (float) n;
			n--;
		}
		return r;
	}

	shared float pow(float x, int n) {
		float r = 1f;
		
		while (n > 0) {
			r = r * x;
			n--;
		}
		
		return r;
	}

	shared float exp(float x) {
	    if (x == 0f) return 1f;
	    if (x == 1f) return FMath::E;

        /* Use continued fraction to approximate, depth = 20 */
	    float x_0 = 1f;
	    for (float d = 20f; d >= 2f; d -= 1f)
            x_0 = 1f + x / d - (x / (d + 1f)) / x_0;

        return 1f + (x / (1f - (x / 2f) / x_0));
	}

	#strategy always
	shared float sin(float x) {
		float s = x;

		/* Calculate using the taylor series */
		#unroll depth = 3
		for (int i = 2; i < 14; i += 4) {
			s -= FMath::pow(x, i) /	FMath::fac(i);
			s += FMath::pow(x, i + 2) / FMath::fac(i + 2);
		}

		return s;
	}
	
	#strategy always
	shared float cos(float x) {
		float s = 1f;

		/* Calculate using the taylor series */
		#unroll depth = 3
		for (int i = 3; i < 15; i += 4) {
			s -= FMath::pow(x, i) / FMath::fac(i);
			s += FMath::pow(x, i + 2) / FMath::fac(i + 2);
		}

		return s;
	}

} 
