/*
 * [BASE-PACKAGE]
 *
 * This package contains the utility to create and use
 * a circular queue.
 */
namespace Queue {
	
	/*
	 * The cyclic queue capsules a pointer to a storage location for
	 * the contained values, indexes for the head and tail, as well as the
	 * maximum size of the queue. Finally the queue has a isEmpty flag, 
	 * that is used to determine wether the queue is full or empty when
	 * the head index is the same as the tail index.
	 */
	restricted struct CyclicQueue<T> {
		
		T* storage;
		
		T defValue;
		
		int size;
		
		int head;
		
		int tail;
		
		bool isEmpty;
	
		/*
		 * Frees the allocated storage of the queue,
		 * as well as the queue itself.
		 */
		shared void destroy<T>() {
			free(self->storage);
			free(self);
		}
		
		/*
		 * Returns true if currently no elements are in the queue.
		 */
		shared bool isEmpty<T>() {
			return self->isEmpty;
		}
		
		/*
		 * Returns true if the amount of elements in the queue is
		 * equal to the specified size when the queue was created.
		 */
		shared bool isFull<T>() {
			return self->head == self->tail && !self->isEmpty;
		}
		
		/*
		 * Enqueue a new value. The value is only enqueued if the 
		 * queue is not full.
		 */
		shared void enqueue<T>(T value) {
			if (self->head == self->tail && !self->isEmpty) {
				/* Queue is full */
				return;
			}
			else {
				/* 
				 * Calculate word offset to the storage location based on the 
				 * Size of the proviso type and the head index
				 */
				int off = self->head * sizeof(T);
				
				/* Write value */
				*(self->storage + off) = value;
				
				/* Increment head index */
				self->head = (self->head + 1) % self->size;
				
				/* Set is empty flag and return */
				self->isEmpty = false;
				return;
			}
		}
		
		/*
		 * Dequeues a value and removes it from the queue. Returns
		 * the default value if the queue is empty.
		 */
		shared T dequeue<T>() {
			if (self->isEmpty) {
				/* Queue is empty, return a default value. */
				return self->defValue;
			}
			else {
				/* Read value from tail */
				T value = *(self->storage + (self->tail * sizeof(T)));
				
				/* Increment tail */
				self->tail = (self->tail + 1) % self->size;
				
				/* If tail now is equal to head the queue must be empty */
				if (self->tail == self->head) self->isEmpty = true;
				
				return value;
			}
		}

		/*
		 * Clears all elements in the queue by resetting the
		 * head and tail indexes, and setting the isEmpty flag to true.
		 */
		shared void clear<T>() {
			self->head = 0;
			self->tail = 0;
			self->isEmpty = true;
			return;
		}
		
		/*
		 * Returns the amount of elements that are currently 
		 * stored in the queue.
		 */
		shared int size<T>() {
			/* Queue is full */
			if (self->head == self->tail && !(self->isEmpty)) 
				return self->size;
			
			int size = self->head - self->tail;
			
			/* Head is behind tail */
			if (size < 0) size = self->size + size;
			
			return size;
		}
		
	}
	
	/*
	 * Allocates a new queue and initializes it.
	 * The passed size will be set as the maximum amount of elements
	 * in the queue.
	 */
	shared CyclicQueue<T>* create<T>(int size, T defValue) {
		/* Allocate memory for storage of given size */
		T* storage = resv(sizeof(T) * size);
		
		/* Initialize, set start values */
		return init<>(CyclicQueue<T>::(storage, defValue, size, 0, 0, true));
	}
	
} 
